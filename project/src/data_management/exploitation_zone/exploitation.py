import pandas as pd 
import duckdb 

from loguru import logger
from src.duckdb_manager import DuckDBManager

def exploitation_driver() -> None:  
    db_manager = DuckDBManager()
    # Get the trusted zone database connection
    trusted_con = db_manager.set_up_trusted_db()
    #lsit tables in the trusted zone
    logger.info("Tables in the trusted zone database: " + str(db_manager.list_tables(db_manager.set_up_trusted_db())))
    # Get the exploitation zone database connection
    exploitation_con = db_manager.set_up_exploitation_db()
    # Clean the tables in the explotation zone to ensure a smooth loading of data from the trusted zone
    db_manager.delete_all_exploitation_tables()

    """#### 2.3 Create the GeographicalInformation table"""

    # Connect to the trusted zone database and retrieve unique geographical information
    # Retrieve distinct combinations of geographic information from the trusted zone tables
    query_geo_info_opendata = """
        SELECT DISTINCT
            Codi_Districte,
            Nom_Districte,
            Codi_Barri,
            Nom_Barri
        FROM OPENDATA
    """
    query_geo_info_portaldades = """
        SELECT DISTINCT
            NULL AS Codi_Districte,
            Districte AS Nom_Districte ,
            NULL AS Codi_Barri,
            Barri AS Nom_Barri
        FROM PORTALDADES
    """

    # Execute query in trusted zone to gather the distinct data
    geo_data_open = trusted_con.execute(query_geo_info_opendata).fetchdf()
    geo_data_portaldades = trusted_con.execute(query_geo_info_portaldades).fetchdf()

    geo_data_combined = pd.concat([geo_data_open, geo_data_portaldades], ignore_index=True).drop_duplicates()
    geo_data_combined.dropna(inplace=True)

    # Step 2: Connect to the exploitation zone database and create the GeographicalInformation table
    create_geo_table_query = """
        CREATE TABLE IF NOT EXISTS GeographicalInformation (
            Codi_Districte CHAR(10),
            Nom_Districte VARCHAR,
            Codi_Barri CHAR(10),
            Nom_Barri VARCHAR,
            PRIMARY KEY (Codi_Districte, Codi_Barri)
        )
    """

    # Execute the query in the exploitation zone
    exploitation_con.execute(create_geo_table_query)

    # Insert the distinct geographical information into the GeographicalInformation table
    geo_data_combined.to_sql('GeographicalInformation', exploitation_con, if_exists='replace', index=False)

    """#### 2.2 Create the OpenData simplified table"""

    # Create a simplification of the OpenData table in the trusted zone database, deleting the Codi_Districte, Nom_Districte, Codi_Barri columns

    #1. Get the table in the trusted zone
    table = trusted_con.execute("SELECT * FROM OPENDATA").fetchdf()
    table = table.copy()
    table.drop(columns=['Codi_Districte', 'Nom_Districte', 'Codi_Barri'], inplace=True)

    #2. Insert the table in the exploitation zone database
    table.to_sql('OpenData', exploitation_con, if_exists='replace', index=False)

    """#### 2.5 Create the PortalDades simplified table"""

    table = trusted_con.execute("SELECT * FROM PORTALDADES").fetchdf()
    table = table.copy()
    table.drop(columns=['Districte', 'Preu_1Trim', 'Preu_2Trim', 'Preu_3Trim', 'Preu_4Trim'], inplace=True)
    #rename Barri to Nom_Barri and Districte to Nom_Districte
    table.rename(columns={'Barri': 'Nom_Barri'}, inplace=True)
    table.to_sql('PortalDades', exploitation_con, if_exists='replace', index=False)

    """#### 2.6 Create the unified table with Socioeconomic and Demografic data

    This table is created to unify all data that is not redundant and extract all possible information from the data in a posterior analysis.
    """

    tableod = exploitation_con.execute("SELECT * FROM OPENDATA").fetchdf()
    tablepd = exploitation_con.execute("SELECT * FROM PORTALDADES").fetchdf()

    #merge the tables on nom_barri and year
    table = pd.merge(tableod, tablepd, on=['Nom_Barri', 'Any'], how='outer')
    table.to_sql('UnifiedData', exploitation_con, if_exists='replace', index=False)

    """## 3. Close database connections.

    Close database connections to ensure changes are made and avoid errors.
    """

    trusted_con.close()
    exploitation_con.close()
    logger.success("Exploitation performed!")